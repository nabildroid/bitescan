import 'dart:math';

import 'package:bitescan/cubits/scanning/scanning_cubit.dart';
import 'package:bitescan/cubits/scanning/scanning_state.dart';
import 'package:bitescan/models/shoppingSession.dart';
import 'package:bitescan/utils/utils.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class ProgressChart extends StatelessWidget {
  const ProgressChart({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<ScanningCubit, ScanningState>(builder: (context, state) {
      final values = _PointsPrediction.generateGraphValues(state.shoppings);

      return _ProgressChart(
        futureValue: values[8],
        nowValue: values[state.shoppings.isEmpty ? 2 : 4],
        values: values,
      );
    });
  }
}

class _ProgressChart extends StatelessWidget {
  final double nowValue;
  final double futureValue;

  final List<double> values;

  const _ProgressChart({
    super.key,
    required this.nowValue,
    required this.futureValue,
    required this.values,
  });

  @override
  Widget build(BuildContext context) {
    var points = values;

    if (isRTL(context)) {
      points = points.reversed.toList();
    }

    final nextWeek = DateTime.now().add(Duration(days: 7));
    final futureLabel =
        "${nextWeek.day.toString().padLeft(2, '0')}/${nextWeek.month.toString().padLeft(2, '0')}";

    return LineChart(
      LineChartData(
        borderData: FlBorderData(
          show: false,
        ),
        gridData: FlGridData(
          show: false,
        ),
        titlesData: FlTitlesData(
          show: false,
        ),
        minY: 0,
        lineTouchData: LineTouchData(
          enabled: false,
          touchTooltipData: LineTouchTooltipData(
            getTooltipColor: (spot) => Colors.black87,
            tooltipPadding: EdgeInsets.symmetric(horizontal: 5, vertical: 1),
            tooltipBorder: BorderSide(
              color: Colors.black,
              width: 1,
            ),
            tooltipRoundedRadius: 8,
            tooltipMargin: -24,
            tooltipHorizontalAlignment: FLHorizontalAlignment.right,
            getTooltipItems: (touchedSpots) {
              return touchedSpots
                  .map((e) => LineTooltipItem(
                        e.y == nowValue
                            ? AppLocalizations.of(context)!.home_chart_now
                            : futureLabel,
                        GoogleFonts.roboto(
                          color: Colors.white,
                          fontSize: 11,
                        ),
                      ))
                  .toList();
            },
          ),
        ),
        showingTooltipIndicators: [
          ShowingTooltipIndicators([
            LineBarSpot(
              LineChartBarData(),
              0,
              FlSpot(points.indexOf(nowValue) + 0.0, nowValue),
            ),
          ]),
          ShowingTooltipIndicators([
            LineBarSpot(
              LineChartBarData(),
              1,
              FlSpot(points.indexOf(futureValue) + 0.0, futureValue),
            ),
          ])
        ],
        lineBarsData: [
          LineChartBarData(
            color: Colors.black,
            spots:
                points.map((e) => FlSpot(points.indexOf(e) + 0.0, e)).toList(),
            isCurved: true,
            barWidth: 2.5,
            isStrokeCapRound: true,
            // showingIndicators: [0, 1, 2, 3, 4, 5, 6, 7],
            dotData: FlDotData(
              checkToShowDot: (spot, barData) {
                return spot.y == futureValue || spot.y == nowValue;
              },
            ),
            belowBarData: BarAreaData(
              gradient: LinearGradient(
                begin: Alignment(0, -3.5),
                end: Alignment(0.2, 1),
                stops: [0.5, 0.9],
                transform: GradientRotation(0),
                colors: [
                  Colors.black26,
                  Colors.transparent,
                ],
              ),
              show: true,
            ),
          ),
        ],
      ),
    );
  }
}

// generated by https://chatgpt.com/c/6769c093-cb90-8005-a1f5-4125f5726e1f
abstract class _PointsPrediction {
  static List<double> generateGraphValues(Set<Shoppingsession> sessions) {
    // Sort sessions by creation date
    final sortedSessions = sessions.toList()
      ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

    DateTime now = DateTime.now();
    List<Shoppingsession> pastSessions =
        sortedSessions.where((s) => s.createdAt.isBefore(now)).toList();

    // Step 1: Calculate past values (1-3)
    List<double> pastValues = _calculatePastValues(pastSessions);

    // Step 2: Calculate "now" value (4)
    double nowValue =
        _calculateNowValue(pastSessions.isNotEmpty ? pastSessions.last : null);

    // Step 3: Predict future values (5-7)
    List<double> futureValues = _predictFutureValues(nowValue);

    // Combine results
    return [...pastValues, nowValue, ...futureValues];
  }

  static List<double> _calculatePastValues(List<Shoppingsession> pastSessions) {
    if (pastSessions.isEmpty) return [1.0, 1.4, 1.25, 1.7];

    double alpha = 0.16; // Smoothing factor
    List<double> engagementScores = pastSessions.map((s) {
      double density = s.duration.inMinutes > 0
          ? s.visitedFoodCodes.length / s.duration.inMinutes
          : 0;
      return min(density * 8.0, 3.0); // Normalize to a max value
    }).toList();

    // Exponential smoothing
    List<double> pastValues = [];
    double smoothed = 1; // Start low
    for (double score in engagementScores) {
      smoothed = alpha * score + (1.3 - alpha) * smoothed;
      pastValues.add(smoothed);
    }

    // Ensure exactly 3 values
    while (pastValues.length < 4) {
      pastValues.insert(0, max(1.0, pastValues.first * 0.8));
    }
    return pastValues.take(4).toList();
  }

  static double _calculateNowValue(Shoppingsession? currentSession) {
    if (currentSession == null) return 2;

    // Calculate engagement for the current session
    double density = currentSession.duration.inMinutes > 0
        ? currentSession.visitedFoodCodes.length /
            currentSession.duration.inMinutes
        : 0;

    double baseValue = min(density * 8, 4); // Scale and normalize

    // Boost the "now" value if the session is very recent
    DateTime now = DateTime.now();
    int daysSinceLastSession = now.difference(currentSession.createdAt).inDays;

    // Add a boost based on recency
    double recencyBoost = daysSinceLastSession == 0
        ? 0.5 // Today
        : max(0.0, 0.5 - (daysSinceLastSession * .125)); // Decay over time

    return baseValue + recencyBoost;
  }

  static List<double> _predictFutureValues(double nowValue) {
    const double K = 10.0; // Maximum value for logistic growth
    const double r = 0.5; // Growth rate
    const int x0 = 2; // Midpoint of the curve

    DateTime now = DateTime.now();

    List<double> futureValues = [];
    for (int i = 1; i <= 6; i++) {
      double futureValue = K / (1 + exp(-r * (i - x0))); // Logistic growth

      // Adjust future values based on "now" and decay over time
      double blendFactor = 0.85; // Blend with "now"
      futureValue = nowValue + (futureValue - nowValue) * blendFactor;

      // Dampen if the last session was long ago
      futureValue *= (1.0 - 0.05 * i); // Reduce slightly with time

      // Add randomness for variety
      double randomFactor = (0.97 + Random().nextDouble() * 0.06);
      futureValue *= randomFactor;

      futureValues.add(futureValue);
    }

    return futureValues;
  }
}
